% Grid size
ROWS = 50;
COLS = 50;
MU = 5;       % average log scale
SIGMA = 1;  % spread (higher = more extremes)
SPREAD_RATE = 0.2;
HEAL_RATE = 8;
IMMUNITY_LOSS_RATE = 40;

population = round(lognrnd(MU, SIGMA, ROWS, COLS));

% Display population as heatmap
[x, y] = meshgrid(1:COLS, 1:ROWS);  % grid coordinates
x = x(:);  % flatten to vectors
y = y(:);
pop = population(:);  % flatten population matrix

% Scale dot sizes
dotSizes = pop;           % size proportional to population
dotSizes = 1 + 300*dotSizes/max(dotSizes); % normalize for visibility

sizeGrid = reshape(dotSizes, ROWS, COLS) / 100; % scale down

% Plot
figure;
h = scatter(x, y, dotSizes, ones(length(x),3), 'filled'); % start white
axis off;

r = zeros(ROWS, COLS);
r_history = zeros(ROWS, COLS, HEAL_RATE);
b_history = zeros(ROWS, COLS, IMMUNITY_LOSS_RATE);

% Pick one random cell
randRow = randi(ROWS)
randCol = randi(COLS)

% Give it a small red value
r(randRow-1:randRow+1, randCol-1:randCol+1) = 0.5;   % Starting Intensity

b = zeros(ROWS, COLS);
g = 1-r

iter = 0;
h.CData = [r(:), g(:), b(:)];
drawnow;

% Animation loop
while true
    r_history = cat(3, r, r_history(:,:,1:HEAL_RATE - 1));
    b_history = cat(3, b, b_history(:,:,1:IMMUNITY_LOSS_RATE - 1));
    iter = iter + 1;  

    % Pad both red and size matrices for border handling
    r_p = padarray(r, [1, 1], 'replicate');
    s_p = padarray(sizeGrid, [1, 1], 'replicate');
    
    % Compute neighbor contributions
    neighborSum = ...
        2 * r_p(2:end-1, 2:end-1).*s_p(2:end-1, 2:end-1);
        %0.5 * r_p(2:end-1, 3:end).*s_p(2:end-1, 3:end) + ...
        %0.2 * r_p(3:end, 1:end-2).*s_p(3:end, 1:end-2) + ...
        %0.5 * r_p(3:end, 2:end-1).*s_p(3:end, 2:end-1) + ...
        %0.2 * r_p(3:end, 3:end).*s_p(3:end, 3:end);

    infected = SPREAD_RATE * neighborSum .* (1 - r - b);
    healed = 0.8 .* (r_history(:,:,HEAL_RATE));
    
    % Update r and b
    r = r - healed;
    b = b + r - r_history(:,:,0);
    
    % Clamp to valid ranges
    b = max(0, min(b, 1));
    r = max(0, min(r, 1 - b));
    
    % ALWAYS recalculate g to maintain r + g + b = 1
    g = 1 - r - b;
    
    % Final safety clamp
    g = max(0, g);
    
    % Update scatter colors
    h.CData = [r(:), g(:), b(:)];
    drawnow;
    pause(1);
end