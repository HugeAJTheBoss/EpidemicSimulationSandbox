<!DOCTYPE html>
<html>

<head>
  <title>EarthData Receiver (Auto-Connect)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
    }

    .status {
      padding: 20px;
      margin: 20px 0;
      border-radius: 5px;
      background: #f0f0f0;
      font-size: 24px;
      text-align: center;
    }

    .connected {
      background: #d4edda;
      color: #155724;
    }

    .waiting {
      background: #fff3cd;
      color: #856404;
    }

    input {
      padding: 10px;
      width: 400px;
      font-size: 14px;
    }

    #log {
      background: #000;
      color: #0f0;
      padding: 15px;
      height: 400px;
      overflow-y: auto;
      font-family: monospace;
      margin-top: 20px;
    }

    .setup {
      background: #e7f3ff;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }

    #frameStats {
      background: #f8f9fa;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>

<body>
  <h1>EarthData Receiver (Auto-Connect)</h1>

  <div class="status" id="status">Connecting...</div>

  <div id="frameStats"></div>

  <div class="setup">
    <strong>Server URL:</strong><br>
    <input type="text" id="serverUrl" value="https://epidemicsimulationsandbox.onrender.com"
      placeholder="https://epidemicsimulationsandbox.onrender.com">
    <p style="font-size: 12px; color: #666;">Auto-connects on page load. Just open this page and wait!</p>
  </div>

  <div id="log"></div>

  <script>
    let signalingWs = null;
    let peerConnection = null;
    let dataChannel = null;
    let myId = null;
    let peerId = null;

    // Better chunk tracking
    let currentFrame = null;
    let frameChunks = new Map(); // chunkIndex -> chunk data
    let expectedChunks = 0;
    let messageQueue = [];
    let processingQueue = false;

    function log(msg) {
      const logDiv = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML += `[${time}] ${msg}\n`;
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(msg);
    }

    // Auto-connect on page load
    window.onload = () => {
      connect();
    };

    async function connect() {
      const serverUrl = document.getElementById('serverUrl').value;

      log('Connecting to signaling server...');
      document.getElementById('status').textContent = 'Connecting...';

      signalingWs = new WebSocket(serverUrl);

      signalingWs.onopen = () => {
        log('✓ Connected to signaling server');
        document.getElementById('status').textContent = 'Waiting for sender...';
        document.getElementById('status').className = 'status waiting';
      };

      signalingWs.onmessage = async (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'id') {
          myId = data.id;
          log(`My ID: ${myId}`);

          // Register as receiver - automatic matching
          signalingWs.send(JSON.stringify({
            type: 'register',
            role: 'receiver'
          }));
          log('Registered as receiver, waiting for sender...');
        } else if (data.type === 'waiting') {
          log('Waiting for a sender to connect...');
          document.getElementById('status').textContent = '⏳ Waiting for sender...';
        } else if (data.type === 'paired') {
          peerId = data.peerId;
          log(`✓ Paired with sender: ${peerId}`);
          document.getElementById('status').textContent = 'Paired! Establishing connection...';
        } else if (data.type === 'offer') {
          log('Received offer from sender');
          await handleOffer(data.from, data.payload);
        } else if (data.type === 'ice-candidate') {
          if (peerConnection) {
            await peerConnection.addIceCandidate(data.payload);
          }
        }
      };

      signalingWs.onerror = (err) => {
        log('Signaling error - check server URL');
        document.getElementById('status').textContent = '❌ Connection error';
      };

      signalingWs.onclose = () => {
        log('Disconnected from signaling server');
        document.getElementById('status').textContent = '❌ Disconnected';

        // Auto-reconnect after 3 seconds
        setTimeout(() => {
          log('Attempting to reconnect...');
          connect();
        }, 3000);
      };
    }

    async function handleOffer(senderId, offer) {
      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        dataChannel.binaryType = 'arraybuffer';

        dataChannel.onopen = () => {
          log('✓ Data channel opened! Receiving data...');
          document.getElementById('status').textContent = '✓ Receiving Data';
          document.getElementById('status').className = 'status connected';
        };

        dataChannel.onmessage = (event) => {
          // Queue messages for processing
          messageQueue.push(event.data);
          processMessageQueue();
        };

        dataChannel.onclose = () => {
          log('Data channel closed');
          document.getElementById('status').textContent = 'Connection closed';
          document.getElementById('status').className = 'status waiting';
        };
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          signalingWs.send(JSON.stringify({
            type: 'ice-candidate',
            target: senderId,
            payload: event.candidate
          }));
        }
      };

      await peerConnection.setRemoteDescription(offer);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      signalingWs.send(JSON.stringify({
        type: 'answer',
        target: senderId,
        payload: answer
      }));

      log('Answer sent to sender');
    }

    async function processMessageQueue() {
      if (processingQueue || messageQueue.length === 0) return;

      processingQueue = true;

      while (messageQueue.length > 0) {
        const data = messageQueue.shift();

        // Determine if this is a header or chunk
        if (data.byteLength === 12) {
          // This is a header (3 x Uint32 = 12 bytes)
          const header = new Uint32Array(data);
          const frameNum = header[0];
          const chunkIndex = header[1];
          const totalChunks = header[2];

          // New frame?
          if (currentFrame !== frameNum) {
            // Process previous frame if we had one
            if (currentFrame !== null && frameChunks.size > 0) {
              reassembleFrame();
            }

            // Start new frame
            currentFrame = frameNum;
            frameChunks.clear();
            expectedChunks = totalChunks;

            log(`Starting frame ${frameNum} (expecting ${totalChunks} chunks)`);
          }

          // Next message should be the chunk data
          if (messageQueue.length > 0) {
            const chunkData = messageQueue.shift();
            frameChunks.set(chunkIndex, new Uint8Array(chunkData));

            // Update stats
            document.getElementById('frameStats').textContent =
              `Frame ${currentFrame}: ${frameChunks.size}/${expectedChunks} chunks received`;

            // Got all chunks?
            if (frameChunks.size === expectedChunks) {
              reassembleFrame();
            }
          }
        }
      }

      processingQueue = false;
    }

    function reassembleFrame() {
      if (frameChunks.size !== expectedChunks) {
        log(`⚠ Frame ${currentFrame} incomplete: ${frameChunks.size}/${expectedChunks} chunks`);
        // Skip incomplete frames
        frameChunks.clear();
        return;
      }

      // Calculate total size
      let totalSize = 0;
      frameChunks.forEach(chunk => {
        totalSize += chunk.length;
      });

      // Reassemble in order
      const completeData = new Uint8Array(totalSize);
      let offset = 0;

      // Important: iterate in chunk index order
      for (let i = 0; i < expectedChunks; i++) {
        const chunk = frameChunks.get(i);
        if (chunk) {
          completeData.set(chunk, offset);
          offset += chunk.length;
        } else {
          log(`⚠ Missing chunk ${i} in frame ${currentFrame}`);
          frameChunks.clear();
          return;
        }
      }

      log(`✓ Frame ${currentFrame}: ${totalSize.toLocaleString()} bytes complete`);
      processEarthData(completeData.buffer, currentFrame);

      // Clear for next frame
      frameChunks.clear();
    }

    function processEarthData(arrayBuffer, frameNum) {
      // YOUR GAME CODE HERE
      const uint8View = new Uint8Array(arrayBuffer);

      // Verify size
      const expectedSize = 3110400; // Your file size
      if (arrayBuffer.byteLength !== expectedSize) {
        log(`⚠ Size mismatch! Expected ${expectedSize}, got ${arrayBuffer.byteLength}`);
      } else {
        log(`✓ Size correct: ${arrayBuffer.byteLength} bytes`);
      }

      // Example: Update your game world with this data
      // updateGameWorld(uint8View);
      // renderFrame(uint8View);

      // Save first frame to verify it works
      if (frameNum === 1) {
        downloadAsFile(arrayBuffer, 'received_earthdata.bin');
        log('✓ First frame saved as received_earthdata.bin');
      }
    }

    function downloadAsFile(arrayBuffer, filename) {
      const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      log(`Downloaded ${filename} (${arrayBuffer.byteLength} bytes)`);
    }
  </script>
</body>

</html>