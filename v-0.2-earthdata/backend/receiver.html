<!DOCTYPE html>
<html>
<head>
  <title>EarthData Receiver (Chunked)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
    }
    .status {
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      background: #f0f0f0;
      font-size: 18px;
      font-weight: bold;
    }
    .connected { background: #d4edda; }
    #myId {
      background: #fff3cd;
      padding: 20px;
      margin: 20px 0;
      border: 3px solid #ffc107;
      font-size: 24px;
      text-align: center;
    }
    #log {
      background: #000;
      color: #0f0;
      padding: 15px;
      height: 400px;
      overflow-y: auto;
      font-family: monospace;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>EarthData Receiver (Chunked)</h1>
  
  <div class="status" id="status">Connecting...</div>
  
  <div id="myId" style="display:none;">
    <div>YOUR ID:</div>
    <div id="idText" style="color: #d9534f;"></div>
    <div style="font-size: 14px; margin-top: 10px;">Copy this ID and paste it in the sender!</div>
  </div>
  
  <div id="log"></div>

  <script>
    let signalingWs = null;
    let peerConnection = null;
    let dataChannel = null;
    let myId = null;
    
    // Chunk reassembly
    let currentFrame = null;
    let receivedChunks = [];
    let expectedChunks = 0;

    function log(msg) {
      const logDiv = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML += `[${time}] ${msg}\n`;
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(msg);
    }

    async function connect() {
      signalingWs = new WebSocket('ws://localhost:8080');
      
      signalingWs.onopen = () => {
        log('Connected to signaling server');
        document.getElementById('status').textContent = 'Connected - Waiting for ID...';
      };
      
      signalingWs.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        
        if (data.type === 'id') {
          myId = data.id;
          log(`My ID: ${myId}`);
          document.getElementById('status').textContent = 'Ready to receive';
          document.getElementById('status').className = 'status connected';
          document.getElementById('myId').style.display = 'block';
          document.getElementById('idText').textContent = myId;
        } else if (data.type === 'offer') {
          log('Received offer from sender');
          await handleOffer(data.from, data.payload);
        } else if (data.type === 'ice-candidate') {
          if (peerConnection) {
            await peerConnection.addIceCandidate(data.payload);
          }
        }
      };
      
      signalingWs.onerror = (err) => {
        log('Signaling error: ' + err);
      };
    }

    async function handleOffer(senderId, offer) {
      log('Setting up peer connection...');
      
      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });
      
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        dataChannel.binaryType = 'arraybuffer';
        
        dataChannel.onopen = () => {
          log('Data channel opened! Ready to receive earthdata.bin');
          document.getElementById('status').textContent = 'Receiving data...';
          document.getElementById('status').className = 'status connected';
        };
        
        let expectingHeader = true;
        
        dataChannel.onmessage = (event) => {
          const data = event.data;
          
          if (expectingHeader) {
            // This is a header with frame info
            const header = new Uint32Array(data);
            const frameNum = header[0];
            const chunkIndex = header[1];
            const totalChunks = header[2];
            
            // New frame?
            if (currentFrame !== frameNum) {
              // Process previous frame if exists
              if (receivedChunks.length > 0) {
                reassembleFrame();
              }
              
              // Start new frame
              currentFrame = frameNum;
              receivedChunks = [];
              expectedChunks = totalChunks;
            }
            
            expectingHeader = false;
          } else {
            // This is chunk data
            receivedChunks.push(new Uint8Array(data));
            
            // Got all chunks for this frame?
            if (receivedChunks.length === expectedChunks) {
              reassembleFrame();
            }
            
            expectingHeader = true;
          }
        };
        
        dataChannel.onclose = () => {
          log('Data channel closed');
        };
        
        dataChannel.onerror = (err) => {
          log('Data channel error: ' + err);
        };
      };
      
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          signalingWs.send(JSON.stringify({
            type: 'ice-candidate',
            target: senderId,
            payload: event.candidate
          }));
        }
      };
      
      await peerConnection.setRemoteDescription(offer);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      
      signalingWs.send(JSON.stringify({
        type: 'answer',
        target: senderId,
        payload: answer
      }));
      
      log('Answer sent back to sender');
    }

    function reassembleFrame() {
      // Calculate total size
      const totalSize = receivedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
      
      // Combine all chunks
      const completeData = new Uint8Array(totalSize);
      let offset = 0;
      for (const chunk of receivedChunks) {
        completeData.set(chunk, offset);
        offset += chunk.length;
      }
      
      log(`Frame ${currentFrame}: Reassembled ${receivedChunks.length} chunks (${totalSize} bytes)`);
      
      // Process the complete frame
      processEarthData(completeData.buffer, currentFrame);
      
      // Reset for next frame
      receivedChunks = [];
    }

    // YOUR GAME CODE - Process the binary data
    function processEarthData(arrayBuffer, frameNum) {
      const uint8View = new Uint8Array(arrayBuffer);
      
      log(`Processing frame ${frameNum}: ${arrayBuffer.byteLength} bytes`);
      
      // YOUR CODE HERE:
      // - Parse the binary data
      // - Update game state
      // - Render to canvas
      // etc.
      
      // Save first frame to verify
      if (frameNum === 1) {
        downloadAsFile(arrayBuffer, 'received_earthdata.bin');
        log('First frame saved as received_earthdata.bin');
      }
    }

    function downloadAsFile(arrayBuffer, filename) {
      const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Start immediately
    connect();
  </script>
</body>
</html>